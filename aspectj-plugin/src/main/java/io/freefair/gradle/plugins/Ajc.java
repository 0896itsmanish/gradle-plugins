package io.freefair.gradle.plugins;

import lombok.Getter;
import lombok.Setter;
import org.gradle.api.DefaultTask;
import org.gradle.api.file.ConfigurableFileCollection;
import org.gradle.api.file.DirectoryProperty;
import org.gradle.api.file.RegularFileProperty;
import org.gradle.api.provider.ListProperty;
import org.gradle.api.provider.Property;
import org.gradle.api.tasks.*;

import java.util.Collections;
import java.util.stream.Collectors;

@Getter
@Setter
public class Ajc extends DefaultTask {

    @Classpath
    @InputFiles
    private final ConfigurableFileCollection aspectjClasspath = getProject().getLayout().configurableFiles();

    /**
     * Accept as source bytecode any .class files in the .jar files or directories on Path.
     * The output will include these classes, possibly as woven with any applicable aspects. Path is a single argument containing a list of paths to zip files or directories, delimited by the platform-specific path delimiter.
     */
    @Classpath
    @InputFiles
    private final ConfigurableFileCollection inpath = getProject().getLayout().configurableFiles();

    /**
     * Weave binary aspects from jar files and directories on path into all sources.
     * The aspects should have been output by the same version of the compiler.
     * When running the output classes, the run classpath should contain all aspectpath entries.
     * Path, like classpath, is a single argument containing a list of paths to jar files, delimited by the platform- specific classpath delimiter.
     */
    @Classpath
    @InputFiles
    private final ConfigurableFileCollection aspectpath = getProject().getLayout().configurableFiles();

    /**
     * Put output classes in zip file output.jar.
     */
    @Optional
    @OutputFile
    private final RegularFileProperty outjar = newOutputFile();

    /**
     * Generate aop xml file for load-time weaving with default name (META-INF/aop-ajc.xml).
     */
    @Input
    private final Property<Boolean> outxml = getProject().getObjects().property(Boolean.class);

    /**
     * Generate aop.xml file for load-time weaving with custom name.
     */
    @Optional
    @OutputFile
    private final RegularFileProperty outxmlfile = newOutputFile();

    /**
     * Generate a build .ajsym file into the output directory.
     * Used for viewing crosscutting references by tools like the AspectJ Browser.
     */
    @Input
    private final Property<Boolean> crossrefs = getProject().getObjects().property(Boolean.class);

    /**
     * Emit the version of the AspectJ compiler.
     */
    @Input
    private final Property<Boolean> version = getProject().getObjects().property(Boolean.class);

    /**
     * Specify where to find user class files.
     * Path is a single argument containing a list of paths to zip files or directories, delimited by the platform-specific path delimiter.
     */
    @CompileClasspath
    @InputFiles
    private final ConfigurableFileCollection classpath = getProject().getLayout().configurableFiles();

    /**
     * Override location of VM's bootclasspath for purposes of evaluating types when compiling.
     * Path is a single argument containing a list of paths to zip files or directories, delimited by the platform-specific path delimiter.
     */
    @Optional
    @CompileClasspath
    @InputFiles
    private final ConfigurableFileCollection bootclasspath = getProject().getLayout().configurableFiles();

    /**
     * Override location of VM's extension directories for purposes of evaluating types when compiling.
     * Path is a single argument containing a list of paths to directories, delimited by the platform-specific path delimiter.
     */
    @InputFiles
    private final ConfigurableFileCollection extdirs = getProject().getLayout().configurableFiles();

    /**
     * Specify where to place generated .class files.
     */
    @OutputDirectory
    private final DirectoryProperty destinationDir = newOutputDirectory();

    @Input
    private final Property<String> target = getProject().getObjects().property(String.class);

    @Input
    private final Property<String> source = getProject().getObjects().property(String.class);

    /**
     * Emit no warnings (equivalent to '-warn:none') This does not suppress messages generated by declare warning or Xlint.
     */
    @Optional
    @Input
    private final Property<Boolean> nowarn = getProject().getObjects().property(Boolean.class);

    /**
     * Emit warnings for any instances of the comma-delimited list of questionable code (eg '-warn:unusedLocals,deprecation'):
     *
     *     constructorName        method with constructor name
     *     packageDefaultMethod   attempt to override package-default method
     *     deprecation            usage of deprecated type or member
     *     maskedCatchBlocks      hidden catch block
     *     unusedLocals           local variable never read
     *     unusedArguments        method argument never read
     *     unusedImports          import statement not used by code in file
     *     none                   suppress all compiler warnings
     *
     *
     * -warn:none does not suppress messages generated by declare warning or Xlint.
     */
    @Input
    private final ListProperty<String> warn = getProject().getObjects().listProperty(String.class);

    /**
     * Same as -warn:deprecation
     */
    @Input
    private final Property<Boolean> deprecation = getProject().getObjects().property(Boolean.class);

    /**
     * Emit no errors for unresolved imports
     */
    @Input
    private final Property<Boolean> noImportError = getProject().getObjects().property(Boolean.class);

    /**
     * Keep compiling after error, dumping class files with problem methods
     */
    @Input
    private final Property<Boolean> proceedOnError = getProject().getObjects().property(Boolean.class);

    /**
     * debug attributes level, that may take three forms:
     *
     *     -g         all debug info ('-g:lines,vars,source')
     *     -g:none    no debug info
     *     -g:{items} debug info for any/all of [lines, vars, source], e.g.,
     *                -g:lines,source
     *
     */
    @Input
    private final ListProperty<String> g = getProject().getObjects().listProperty(String.class);

    /**
     * Preserve all local variables during code generation (to facilitate debugging).
     */
    @Input
    private final Property<Boolean> preserveAllLocals = getProject().getObjects().property(Boolean.class);

    /**
     * Compute reference information.
     */
    @Input
    private final Property<Boolean> referenceInfo = getProject().getObjects().property(Boolean.class);

    /**
     * Specify default source encoding format.
     */
    @Optional
    @Input
    private final Property<String> encoding = getProject().getObjects().property(String.class);


    @Input
    private final Property<Boolean> verbose = getProject().getObjects().property(Boolean.class);

    /**
     * Emit messages about weaving
     */
    @Input
    private final Property<Boolean> showWeaveInfo = getProject().getObjects().property(Boolean.class);

    /**
     * Specify a log file for compiler messages.
     */
    @OutputFile
    @Optional
    private final RegularFileProperty log = newOutputFile();

    /**
     * Show progress (requires -log mode).
     */
    private final Property<Boolean> progress = getProject().getObjects().property(Boolean.class);

    /**
     * Display speed information.
     */
    @Input
    private final Property<Boolean> time = getProject().getObjects().property(Boolean.class);

    /**
     * Causes compiler to terminate before weaving
     */
    @Input
    private final Property<Boolean> XterminateAfterCompilation = getProject().getObjects().property(Boolean.class);

    /**
     * Causes the compiler to calculate and add the SerialVersionUID field to any type implementing Serializable that is affected by an aspect.
     * The field is calculated based on the class before weaving has taken place.
     */
    @Input
    private final Property<Boolean> XaddSerialVersionUID = getProject().getObjects().property(Boolean.class);

    /**
     * (Experimental) do not inline around advice
     */
    @Input
    private final Property<Boolean> XnoInline = getProject().getObjects().property(Boolean.class);

    /**
     * (Experimental) Normally it is an error to declare aspects Serializable. This option removes that restriction.
     */
    @Input
    private final Property<Boolean> XserializableAspects = getProject().getObjects().property(Boolean.class);

    /**
     * (Experimental) Create class files that can't be subsequently rewoven by AspectJ.
     */
    @Input
    private final Property<Boolean> XnotReweavable = getProject().getObjects().property(Boolean.class);

    @Optional
    @InputFiles
    private final ConfigurableFileCollection files = getProject().getLayout().configurableFiles();

    @TaskAction
    public void ajc() {
        getProject().javaexec(ajc -> {
            ajc.setClasspath(aspectjClasspath);
            ajc.setMain("org.aspectj.tools.ajc.Main");

            if (!inpath.isEmpty()) {
                ajc.args("-inpath", inpath.getAsPath());
            }

            if (!aspectpath.isEmpty()) {
                ajc.args("-aspectpath", aspectpath.getAsPath());
            }

            if (outjar.isPresent()) {
                ajc.args("-outjar", outjar.get().getAsFile().getAbsolutePath());
            }

            if (outxml.getOrElse(false)) {
                ajc.args("-outxml");
            }

            if (outxmlfile.isPresent()) {
                ajc.args("-outxmlfile", outxmlfile.get().getAsFile().getAbsolutePath());
            }

            if (crossrefs.getOrElse(false)) {
                ajc.args("-crossrefs");
            }

            if (version.getOrElse(false)) {
                ajc.args("-version");
            }

            if (!classpath.isEmpty()) {
                ajc.args("-classpath", classpath.getAsPath());
            }

            if (!bootclasspath.isEmpty()) {
                ajc.args("-bootclasspath", bootclasspath.getAsPath());
            }

            if (!extdirs.isEmpty()) {
                ajc.args("-extdirs", extdirs.getAsPath());
            }

            if (destinationDir.isPresent()) {
                ajc.args("-d", destinationDir.get().getAsFile().getAbsolutePath());
            }

            if (target.isPresent()) {
                ajc.args("-target", target.get());
            }

            if (source.isPresent()) {
                ajc.args("-source", source.get());
            }

            if (nowarn.getOrElse(false)) {
                ajc.args("-nowarn");
            }

            if (!warn.getOrElse(Collections.emptyList()).isEmpty()) {
                ajc.args("-warn:" + warn.get().stream().collect(Collectors.joining(",")));
            }

            if (deprecation.getOrElse(false)) {
                ajc.args("-deprecation");
            }

            if (noImportError.getOrElse(false)) {
                ajc.args("-noImportError");
            }

            if (proceedOnError.getOrElse(false)) {
                ajc.args("-proceedOnError");
            }

            if (!g.getOrElse(Collections.emptyList()).isEmpty()) {
                ajc.args("-g:" + g.get().stream().collect(Collectors.joining(",")));
            }

            if (preserveAllLocals.getOrElse(false)) {
                ajc.args("-preserveAllLocals");
            }

            if (referenceInfo.getOrElse(false)) {
                ajc.args("-referenceInfo");
            }

            if (encoding.isPresent()) {
                ajc.args("-encoding", encoding.get());
            }

            if (verbose.getOrElse(false)) {
                ajc.args("-verbose");
            }

            if (showWeaveInfo.getOrElse(false)) {
                ajc.args("-showWeaveInfo");
            }

            if (log.isPresent()) {
                ajc.args("-log", log.get().getAsFile().getAbsolutePath());
            }

            if (progress.getOrElse(false)) {
                ajc.args("-progress");
            }

            if (time.getOrElse(false)) {
                ajc.args("-time");
            }

            if (XterminateAfterCompilation.getOrElse(false)) {
                ajc.args("-XterminateAfterCompilation");
            }

            if (XaddSerialVersionUID.getOrElse(false)) {
                ajc.args("-XaddSerialVersionUID");
            }

            if (XnoInline.getOrElse(false)) {
                ajc.args("-XnoInline");
            }

            if (XserializableAspects.getOrElse(false)) {
                ajc.args("-XserializableAspects");
            }

            if (XnotReweavable.getOrElse(false)) {
                ajc.args("-XnotReweavable");
            }

            if (!files.isEmpty()) {
                ajc.args(files.getFiles());
            }
        });
    }
}
